<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>2048 - Ziv</title>
  <style>
    :root{
      --board-size: min(92vw, 460px);
      --gap: 12px;
      --bg: #faf8ef;
      --tile-bg: #bbada0;
      --cell-bg: rgba(238,228,218,0.35);
      --font: "Clear Sans", Arial, sans-serif;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:20px;
      background:var(--bg);
      font-family:var(--font);
      color:#776e65;
    }
    .container{
      width:var(--board-size);
      max-width:100%;
    }
    .header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:14px;
    }
    h1{font-size:28px;margin:0}
    .score{
      background:var(--tile-bg);
      color:#fff;
      padding:8px 12px;
      border-radius:6px;
      text-align:center;
      font-weight:700;
    }

    /* 主要改動：將 grid 設為固定寬高（寬度由 --board-size 控制），並使用 4x4 的等分列與欄 */
    #game{
      background:var(--tile-bg);
      padding:var(--gap);
      border-radius:10px;
      touch-action:none;
      user-select:none;
      width:100%;
    }
    .grid{
      width:100%;
      height:var(--board-size); /* 確保高度等於 board-size，與 container width 配合產生正方形整個棋盤 */
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(4, 1fr); /* 等分四個 row，確保每格為正方形 */
      gap:var(--gap);
    }
    /* 每格不使用百分比的硬算寬高，改用 grid 的等分與 grid 容器的固定高度，維持穩定尺寸 */
    .cell{
      background:var(--cell-bg);
      border-radius:6px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:700;
      color:#776e65;
      font-size:clamp(18px, 3.8vw, 28px);
      overflow:hidden;
      position:relative;
    }
    /* tile 佔滿 cell（但不會影響 cell 的尺寸）*/
    .tile{
      width:100%;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius:6px;
      font-weight:700;
      transition: transform 120ms ease, background 120ms ease;
      box-sizing:border-box;
      padding:4px;
    }

    /* 顏色 */
    .t2{background:#eee4da}
    .t4{background:#ede0c8}
    .t8{background:#f2b179;color:#fff}
    .t16{background:#f59563;color:#fff}
    .t32{background:#f67c5f;color:#fff}
    .t64{background:#f65e3b;color:#fff}
    .t128{background:#edcf72;color:#fff;font-size:18px}
    .t256{background:#edcc61;color:#fff;font-size:18px}
    .t512{background:#edc850;color:#fff;font-size:18px}
    .t1024{background:#edc53f;color:#fff;font-size:16px}
    .t2048{background:#edc22e;color:#fff;font-size:16px}

    .controls{
      margin-top:12px;
      display:flex;
      gap:10px;
      justify-content:center;
    }
    button{
      background:#8f7a66;color:#fff;border:0;padding:10px 14px;border-radius:6px;cursor:pointer;font-weight:700;
    }
    .hint{margin-top:10px;color:#9b8f85;font-size:13px;text-align:center}
    @media (min-width:800px){
      h1{font-size:34px}
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>2048</h1>
      <div class="score" id="score">0</div>
    </div>

    <div id="game" aria-label="2048 game area">
      <div class="grid" id="grid"></div>
    </div>

    <div class="controls">
      <button id="btn-restart">重新開始</button>
      <button id="btn-undo">還原 (一步)</button>
    </div>

    <div class="hint">桌機：方向鍵 / 手機：滑動</div>
  </div>

  <script>
    const SIZE = 4;
    const gridEl = document.getElementById('grid');
    const scoreEl = document.getElementById('score');
    const btnRestart = document.getElementById('btn-restart');
    const btnUndo = document.getElementById('btn-undo');
    const gameEl = document.getElementById('game');

    let board = [];
    let score = 0;
    let prevState = null;
    let isProcessing = false;

    function initCells(){
      gridEl.innerHTML = '';
      for(let r=0;r<SIZE;r++){
        for(let c=0;c<SIZE;c++){
          const placeholder = document.createElement('div');
          placeholder.className = 'cell';
          gridEl.appendChild(placeholder);
        }
      }
    }

    function emptyBoard(){
      const b = [];
      for(let r=0;r<SIZE;r++) b.push(new Array(SIZE).fill(0));
      return b;
    }

    function spawnRandom(b){
      const empties = [];
      for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if (!b[r][c]) empties.push([r,c]);
      if(empties.length===0) return false;
      const [r,c] = empties[Math.floor(Math.random()*empties.length)];
      b[r][c] = Math.random() < 0.9 ? 2 : 4;
      return true;
    }

    function cloneBoard(b){ return b.map(row => row.slice()); }

    function render(){
      gridEl.querySelectorAll('.cell').forEach((cell, idx) => {
        cell.innerHTML = '';
        const r = Math.floor(idx / SIZE);
        const c = idx % SIZE;
        const v = board[r][c];
        if (v){
          const tile = document.createElement('div');
          tile.className = 'tile t' + v;
          tile.textContent = v;
          cell.appendChild(tile);
        }
      });
      scoreEl.textContent = score;
    }

    function boardEquals(a,b){
      for(let r=0;r<SIZE;r++) for(let c=0;c<SIZE;c++) if (a[r][c] !== b[r][c]) return false;
      return true;
    }

    function canMove(b){
      for(let r=0;r<SIZE;r++){
        for(let c=0;c<SIZE;c++){
          if (b[r][c] === 0) return true;
          const v = b[r][c];
          if (c < SIZE-1 && b[r][c+1] === v) return true;
          if (r < SIZE-1 && b[r+1][c] === v) return true;
        }
      }
      return false;
    }

    function processLine(arr, dir){
      let a = arr.slice();
      let reversed = false;
      if (dir === 'right'){ a = a.slice().reverse(); reversed = true; }
      let compact = a.filter(x => x !== 0);
      let merged = [];
      for(let i=0;i<compact.length;i++){
        if (i+1 < compact.length && compact[i] === compact[i+1]){
          const val = compact[i]*2;
          merged.push(val);
          score += val;
          i++;
        } else {
          merged.push(compact[i]);
        }
      }
      while(merged.length < SIZE) merged.push(0);
      if (reversed) merged = merged.reverse();
      return merged;
    }

    function move(direction){
      if (isProcessing) return false;
      isProcessing = true;
      const before = cloneBoard(board);
      prevState = {board: cloneBoard(board), score};

      if (direction === 'left' || direction === 'right'){
        for(let r=0;r<SIZE;r++){
          const row = board[r].slice();
          board[r] = processLine(row, direction);
        }
      } else {
        for(let c=0;c<SIZE;c++){
          const col = [];
          for(let r=0;r<SIZE;r++) col.push(board[r][c]);
          const processed = processLine(col, direction === 'up' ? 'left' : 'right');
          for(let r=0;r<SIZE;r++) board[r][c] = processed[r];
        }
      }

      const changed = !boardEquals(before, board);
      if (changed){
        spawnRandom(board);
        render();
      }
      isProcessing = false;
      return changed;
    }

    function startGame(){
      board = emptyBoard();
      score = 0;
      prevState = null;
      initCells();
      spawnRandom(board);
      spawnRandom(board);
      render();
    }

    function undo(){
      if (!prevState) return;
      board = cloneBoard(prevState.board);
      score = prevState.score;
      prevState = null;
      render();
    }

    function onKey(e){
      const key = e.key;
      let moved = false;
      if (key === 'ArrowLeft' || key === 'a' || key === 'A') moved = move('left');
      else if (key === 'ArrowRight' || key === 'd' || key === 'D') moved = move('right');
      else if (key === 'ArrowUp' || key === 'w' || key === 'W') moved = move('up');
      else if (key === 'ArrowDown' || key === 's' || key === 'S') moved = move('down');
      if (moved){
        setTimeout(()=> { if (!canMove(board)) setTimeout(()=>alert('遊戲結束！分數：' + score), 80); }, 50);
      }
    }

    // 手勢
    let touchStartX = 0, touchStartY = 0;
    const threshold = 30;
    gameEl.addEventListener('touchstart', (e) => {
      if (e.touches && e.touches.length > 0){
        touchStartX = e.touches[0].clientX;
        touchStartY = e.touches[0].clientY;
      }
    }, {passive: true});
    gameEl.addEventListener('touchmove', (e) => { e.preventDefault(); }, {passive: false});
    gameEl.addEventListener('touchend', (e) => {
      if (!e.changedTouches || !e.changedTouches[0]) return;
      const dx = e.changedTouches[0].clientX - touchStartX;
      const dy = e.changedTouches[0].clientY - touchStartY;
      if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > threshold){
        if (dx > 0) move('right'); else move('left');
      } else if (Math.abs(dy) > threshold){
        if (dy > 0) move('down'); else move('up');
      }
      setTimeout(()=> { if (!canMove(board)) setTimeout(()=>alert('遊戲結束！分數：' + score), 80); }, 60);
    }, {passive: true});

    btnRestart.addEventListener('click', startGame);
    btnUndo.addEventListener('click', undo);
    window.addEventListener('keydown', onKey);

    startGame();
  </script>
</body>
</html>